package gen

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/bytecodealliance/wasm-tools-go/internal/codec"
)

// File represents a generated file. It may be a Go file
type File struct {
	// Name is the short name of the file.
	// If Name ends in ".go" this file will be treated as a Go file.
	Name string

	// GeneratedBy is the name of the program that generated this file.
	// Leave empty to omit the "Code generated by ..." header.
	GeneratedBy string

	// GoBuild contains build tags, serialized as //go:build ...
	// Ignored if this is not a Go file.
	GoBuild string

	// PackageDocs are doc comments that preceed the package declaration.
	// These will be wrapped and each line prefixed with // when serialized.
	// Ignored if this is not a Go file.
	PackageDocs string

	// Package this file belongs to.
	Package *Package

	// Scope is the naming scope of this file, used for package import names.
	Scope

	// Imports maps Go package imports from package path to local name, e.g. {"encoding/json": "json"}.
	Imports map[string]string

	// Header is the file header, written before content.
	Header string

	// Content is the file content.
	Content []byte

	// Trailer is the file trailer, written after content.
	Trailer string
}

// NewFile returns a newly initialized file.
func NewFile(pkg *Package, name string) *File {
	return &File{
		Name:    name,
		Package: pkg,
		Scope:   NewScope(pkg),
		Imports: make(map[string]string),
	}
}

// IsGo returns true if f represents a Go file.
func (f *File) IsGo() bool {
	return strings.HasSuffix(f.Name, ".go")
}

// HasContent returns true if f contains any content.
func (f *File) HasContent() bool {
	if !f.IsGo() {
		return len(f.Content) > 0
	}
	if len(f.PackageDocs) > 0 || len(f.Header) > 0 || len(f.Content) > 0 || len(f.Trailer) > 0 {
		return true
	}
	for _, name := range f.Imports {
		if name == "_" {
			// This file has content because it imports a Go package for its side effects.
			return true
		}
	}
	return false
}

// Write implements [io.Writer].
func (f *File) Write(content []byte) (int, error) {
	f.Content = append(f.Content, content...)
	return len(content), nil
}

// WriteString implements [io.StringWriter].
func (f *File) WriteString(s string) (int, error) {
	f.Content = append(f.Content, []byte(s)...)
	return len(s), nil
}

const HeaderPattern = `// Code generated by %s. DO NOT EDIT.`

// Bytes returns the byte values of this file.
func (f *File) Bytes() ([]byte, error) {
	if !f.IsGo() {
		return f.Content, nil
	}

	var b bytes.Buffer

	if f.GeneratedBy != "" {
		b.WriteString(fmt.Sprintf(HeaderPattern, f.GeneratedBy))
		b.WriteString("\n\n")
	}

	if f.GoBuild != "" {
		b.WriteString("//go:build ")
		b.WriteString(f.GoBuild)
		b.WriteString("\n\n")
	}

	if f.PackageDocs != "" {
		b.WriteString(FormatDocComments(f.PackageDocs, false))
	}
	b.WriteString("package ")
	b.WriteString(f.Package.Name)
	b.WriteString("\n\n")

	if len(f.Imports) > 0 {
		b.Write(Imports(f.Imports))
		b.WriteString("\n\n")
	}

	b.Write([]byte(f.Header))
	b.Write(f.Content)
	b.Write([]byte(f.Trailer))

	unformatted := b.Bytes()
	formatted, err := format.Source(unformatted)
	if err != nil {
		return unformatted, fmt.Errorf("error in %s: %w", f.Name, err)
	}
	return formatted, nil
}

// DeclareName adds a package-scoped identifier to [File] f.
// It additionally checks the file-scoped declarations (local package names).
// It returns the package-unique name (which may be different than name).
func (f *File) DeclareName(name string) string {
	return f.Package.DeclareName(f.Scope.DeclareName(name))
}

// Import imports the Go package specified by path, returning the local name for the imported package.
// The path argument may have an optional "#name" suffix to specify the local name.
// The returned local name may differ from the specified local name.
func (f *File) Import(path string) string {
	path, name := ParseSelector(path)
	if path == f.Package.Path {
		// Can't import self
		return ""
	}
	if f.Imports[path] == "" {
		f.Imports[path] = f.Scope.DeclareName(name)
	}
	return f.Imports[path]
}

// RelativeName returns a file and package-relative string for a [Package] and name.
// If f belongs to pkg, it returns the local name.
// If f belongs to a different package, it first imports the package,
// then returns a name prefixed with the imported package name.
func (f *File) RelativeName(pkg *Package, name string) string {
	// FIXME: is this redundant, but safer?
	if pkg == f.Package || pkg.Path == f.Package.Path {
		return name
	}
	pkgName := f.Import(pkg.Path + "#" + pkg.Name)
	return pkgName + "." + name
}

// Imports returns Go import syntax for imports.
// The imports argument is a map of import path to local name.
func Imports(imports map[string]string) []byte {
	if len(imports) == 0 {
		return nil
	}
	var b bytes.Buffer
	b.WriteString("import (\n")
	for _, path := range codec.SortedKeys(imports) {
		name := imports[path]
		b.WriteRune('\t')
		if path != name && !strings.HasSuffix(path, "/"+name) {
			b.WriteString(name)
			b.WriteRune(' ')
		}
		b.WriteString("\"")
		b.WriteString(path)
		b.WriteString("\"\n")
	}
	b.WriteString(")")
	return b.Bytes()
}
